1. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
done
2. Что такое кооперативная многозадачность и она ли ли в Java. Если да, то какие преимущества. Если нет, то какая тогда в Java?

невытесняющая (nonpreemptive) - самый дубовый тип многозадачности. В память загружаются все программы,
претендующие на параллельное выполнение. Одна из них получает статус переднеплановой (foreground), 
а остальные растворяются в фоне (background). Все процессорное время отдается переднеплановому процессу,
а задние включаются только при непосредственной активизации, также занимая для себя все время.
К слову, для меня наиболее близким примером похожей штуки является переключение процессов в терминалах Unix 
с помощью ctrl+z и команд bg и fg.

3. Что такое "зеленый потоки" и они ли ли в Java (в HotSpot JVM.6)?
done
4. Различия в интерфейсах Runnable и Callable.
done
5. Напишите минимальный неблокирующий стек (всего два метода — push() и pop()).
6. Напишите минимальный copy-on-write ArrayList (всего четыре метода — void add(int indx, int item), int get(int indx), void remove(int indx), int size()).

7. Различя между Thread.isInterrupded() и Thread.interrupded().

Thread.isInterrupded() - class method 
Thread.interrupded() - static method
Thread.isInterrupded() = currentThread().isInterrupted(false);
Thread.interrupded() = currentThread().isInterrupted(true);
After each throw of InterruptedException flag is interupted reseted.
By calling Thread.currentThread.interrupt(), you set the interrupt flag of the thread,
so higher level interrupt handlers will notice it and can handle it appropriately.


8. Что происходит при вызове Thread.interrupt()?
9. Некоторые из следующих методов deprecated а некоторые и не были никогда реализованы. Какие? Thread.interrupt(), Thread.stop(), Thread.yield(), Thread.suspend(), Thread.resume(), Thread.join(), Thread.start(), Thread.run(), Thread.sleep().
10. Что Вы знаете о асинхронных вызовов методов? Есть ли это в самом языке Java? Если есть, то как реализовано? Если нет, то как бы Вы реализовали?
11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.
12. Что изменилось между JMM до Java 5 и NewJMM после Java 5?
13. В классе String все поля финальные. Можно ли убрать ключевое слово финал? Ведь сеттеров все равно нет — следовательно поля нельзя переустановить.
14. Что такое ordering, visibility, atomicity, happend-before, mutual exclusion. И показать на примерах volatile, AtomicInteger, synchronize{} — что из вышеперечисленного списка присутствует и при каких вариантах использования.
15. Назовите отличия synchronize{} и ReentrantLock.
16. Что из данных вызовов создает happend-before: Thread.sleep(), Thread.join(), Thread.yield(), Thread.start(), Thread.run(), Thread.isAlive(), Thread.getState()?
17. Перечислите известные Вам способы борьбы с priority inversion, назовите классы систем где они особенно опасны.
18. Перечислите известные Вам способы 1)избежать 2)побороть возникшие deadlock-и (представьте, что вы пишете ядро RDBMS).
19. Расскажите о паттернах Reactor/Proactor?
20. Что такое "monitor"?
21. Что такое "private mutex"?
22. Что такое "priority inheritance"?
23. Что такое "backoff protocol (expotential backoff)"?
24. Что такое "task stealing"?
25. Что такое "ABA problem"?
26. Что такое "test-end-set"?
27. Что такое "test-and-test-end-set"?
28. Что такое "spin lock"?
29. Что такое "sequential consistency"?
30. Что такое "sense-reversing barrier"?
31. Что такое "safe publication"?
32. Что это за свойство — "reentrancy"?
33. Что такое "recursive parallelism"?
34. Что такое "iterative parallelism"?
35. Что это за вариант архитектуры "pipeline"?
36. Что такое "poison message"?
37. Что такое "mutual exclusion"? Примеры как добиться в Java.
38. Что такое "condition waiting"? Примеры как добиться в Java.
39. Преимущества SheduledThreadPool перед java.util.Timer.
40. Различия между java.util.concurrent.Atomic*.compareAndSwap() и java.util.concurrent.Atomic*.weakCompareAndSwap().
41. Что в SynchronousQueue уникально для BlockingQueue.
42. Что такое "рандеву"? При помощи каких классов в Java его можно организовать?
43. Что такое "false sharing". Может ли происходит в Java. Если есть, то приведите примеры и как бороться. Если нет, то как побороли разработчики JVM.
44. Thread.getState() возвращает экземпляр Thread.State. Какие возможны значения?
45. Напишите простейший ограниченный буфер для многих производителей/многих потребителей с использованием synchronize{}. С использованием ReentrantLock.
46. У ReentrantLock созданного с аргументом true все же один из методов захвата блоктровки — не fair. Какой? Как это обойти?
47. Приведите наиболее существенное отличие между CountDownLatch и Barrier.
48. Что Вы знаете о Erlang? Что в нем есть существенного связанного с многопоточностью такого, чего нет в Java?
49. Что Вы знаете о CSP? Что в нем есть существенного связанного с многопоточностью такого, чего нет в Java?
50. Отличие Thread.start() и Thread.run()?


final поля позволяют избежать reorderinga

В старой JMM у каждого из запущенных потоков был свой кеш (working memory), в котором хранились некоторые 
состояния объектов, которыми этот поток манипулировал. При некоторых условиях кеш синхронизировался с основной
памятью (main memory), но тем не менее существенную часть времени значения в основной памяти и в кеше могли расходиться.
В новой модели памяти от такой концепции отказались, потому что то, где именно хранится значение, 
вообще никому не интересно.Важно лишь то, при каких условиях один поток видит изменения, выполненные другим потоком.
Кроме того, железо и без того достаточно умно, чтобы что-то кешировать, складывать в регистры и вытворять прочие операции.

http://habrahabr.ru/post/133981/

contention — ситуация, когда несколько сущностей одновременно пытаются владеть одним и тем же ресурсом, 
который предназначен для монопольного использования






The Little Book of SEMAPHORES
